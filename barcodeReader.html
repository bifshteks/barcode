<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title>RESULT</title>
</head>

<body>
	<div>
		<!-- <div class="inputoutput">
			<img id="imageSrc" alt="No Image" / >
			<div class="caption">imageSrc
				<input type="file" id="fileInput" name="file" />
			</div>
		</div> -->
		<div class="inputoutput">
			BASE64:
			<input type="file" onchange="encodeImageFileAsURL(this)">
			<!-- <canvas id="canvasOutput"></canvas>
			<canvas id="canvasSobelOutput"></canvas>
			<div class="caption">canvasOutput</div> -->
		</div>
		<div id="cannyTest"></div>
		<canvas id="canvasCroped"></canvas>
	</div>
  <canvas id="mid"></canvas>
</body>
<script src="quagga.js"></script>
<script src="../tracking.js"></script>
<script>
function encodeImageFileAsURL(element) {
        // /////////////////////
        //  получаю полное изображениеб перевожу в BASE64
        ////////////////////////
	var file = element.files[0];
	var reader = new FileReader();
	reader.onloadend = function() {
		console.log('RESULT', reader.result);
        // /////////////////////
        //  запускаю квагу на полное изображение в base64
        ////////////////////////
		Quagga.decodeSingle({
			decoder: {
				readers: ["code_128_reader"]
			},
			locate: true,
			src: reader.result, // or 'data:image/jpg;base64,' + data
		}, function(result) {
			if (result.codeResult) {
        // /////////////////////
        //  получаю бокс с баркодом на полном изображении
        ////////////////////////
				var testFDW = result.boxes[0][0];
				var testSDW = result.boxes[0][3];
				var testFDH = result.boxes[0][0];
				var testSDH = result.boxes[0][1];
				var testW = Math.floor(Math.sqrt(Math.pow(testSDW[0] - testFDW[0], 2) + Math.pow(testSDW[1] - testFDW[1], 2)))
				var testH = Math.floor(Math.sqrt(Math.pow(testSDH[1] - testFDH[1], 2) + Math.pow(testSDH[0] - testFDH[0], 2)))
				console.log('TEST width: ', testW)

				var barcodeValue = parseInt(result.codeResult.code);
				var fullBarcodeW = testW;
				var fullBarcodeH = testH;

				// var txtBase = document.getElementById('cannyTest');
				// txtBase.innerHTML =   'Ширина баркода: ' + barcodeW + '<br>' + 'Значение баркода: ' + barcodeValue + '<br>' + 'В одном сантиметре '+ barcodeW / barcodeValue + ' пикселей';//'BASE64: ' + reader.result +

				console.log('BOXES: ', result.boxes);
				console.log('ANGLE: ', result.angle)

				var canvas = document.getElementById('canvasCroped');
				var context = canvas.getContext('2d');

				var img = new Image();
				img.src = reader.result;
				imgW = img.width;
				imgH = img.height;
				// canvas.width = imgW;
				// canvas.height = imgH;

        // /////////////////////
        //  обрезаю изображение и вставляю в холст обрезанное и перевернутое изображение
        ////////////////////////
				start();

				var croppedBarcodeData = canvas.toDataURL();
				console.log('CROPPEDbarcodeDATA: ', croppedBarcodeData);


        // /////////////////////
        //  запускаю квагу на обрезанное изображение
        ////////////////////////
				Quagga.decodeSingle({
					decoder: {
						readers: ["code_128_reader"]
					},
					locate: true,
					src: croppedBarcodeData // or 'data:image/jpg;base64,' + data
				}, function(result) {
					// if(result.codeResult) {
					//   console.log("result", result.codeResult.code);
					// } else {

        // /////////////////////
        //  если квага хотябы понимаю, что баркод на изображении есть - получаю еще один бокс
        ////////////////////////




					console.log("detected or not detected, who cares");          //
					var resImg = document.createElement('img')                   //
					resImg.src = croppedBarcodeData;                             //
					var divv = document.getElementById('cannyTest');             // просто создаю картинку, которую можно скачать на комп
					divv.appendChild(resImg)                                     //


					console.log('ending boxes', result.boxes);                   
					var endW = result.boxes[0][2][0] - result.boxes[0][0][0];    
					console.log('THAT\'S WIDTH: ', endW)                         


          // вставляю в холст обрезаный баркод с фильтром на вертикальные полосы
          var imageData = context.getImageData(0, 0, canvas.width, canvas.height);
          var verticalImgPix = tracking.Image.verticalConvolve(imageData.data, canvas.width, canvas.height, [1,1.5,-1], 5)
					for (i = 0; i < verticalImgPix.length; i++) {
						imageData.data[i] = verticalImgPix[i];
					};
          context.putImageData(imageData, 0, 0);


          // функция достает из imageData один полный n-й пиксель из 4 значений
          function getFullPixel(data, position){
            // var start = 4 * (position - 1) + 1;
            // console.log('Func start', start);
            var    pix = {};
                pix.r = data[position];
                pix.g = data[position+1];
                pix.b = data[position+2];
                pix.a = data[position+3];
                // console.log('func pix ', pix)
            return pix
          }


          // беру среднюю линию пикселей из обрезанного отфильтрованного изображения
          var midH = Math.floor(canvas.height / 2);
          console.log('MIIIIID H', midH)
          var midW = midH + canvas.width*4;
          var middleLineData = imageData.data.slice(midH*midW, midH*midW + midW);
          var pixelsInMiddleLineData = Math.floor(middleLineData.length/4);



          var startOfBarcode = 0;
          var endOfBarcode = 0;
          console.log('length',middleLineData.length)
          console.log('TRying ', middleLineData[250])
          console.log('ALL IMAGE DATA LENGTH', imageData.data.length)
          console.log('pixel example', getFullPixel(middleLineData, 150))
          
          // var mcanvas = document.getElementById('mid');
          // var mcontext = canvas.getContext('2d');
          // mcanvas.width = 530;
          // mcanvas.height = 1;
          // mcontext.createImageData(530, 100);
          // for(k=1; k<100; k++){

          //   mImgD = mcontext.getImageData(0,0,530,k);
          //   for (i=0; i<mImgD.data.length; i++){
          //     mImgD.data[i] = middleLineData[i]
          //   };
          // mcontext.putImageData(mImgD, 0, k)
          // }

          //////////////////////////
          // прохожу по этой линии с начала до первой полоски бракода, потом с конца до последней полоски баркода
          ///////////////////////
          for (i=0; i<pixelsInMiddleLineData; i++){
            // i is one pixel rgba
            var pixel = getFullPixel(middleLineData,  i);
            
                if (pixel.r <75 && pixel.g <75 && pixel.b <75 ) {//if this pixel is start
                  console.log('FIRST IF')
                    startOfBarcode = i;
                    console.log('START PIXEL', startOfBarcode, pixel)

                    // console.log('BACKWARDS LENTH', Math.floor(middleLineData.length/4))
                    for (k=pixelsInMiddleLineData-1; k>i; k--){
                      var pixelBackwards = getFullPixel(middleLineData,  k);

                      if (pixelBackwards.r <75 && pixelBackwards.g <75 && pixelBackwards.b <75){
                        console.log('SECOND IF')
                        endOfBarcode = k;
                        console.log('END PIXEL', endOfBarcode, pixelBackwards)
                        break;
                      } //else {
                        // console.log('Backwards pixel', pixelBackwards)
                      //}
                    };
                    break;
                }
            
          };

          var BARCODE_WIDTH = endOfBarcode - startOfBarcode;
          console.log('AAAAA I HOPE ITS FINAL ANSWER', BARCODE_WIDTH);

					// }
				});














				function start() {

					// create 2 temporary canvases

					var canvas1 = document.createElement("canvas");
					var ctx1 = canvas1.getContext("2d");
					var canvas2 = document.createElement("canvas");
					var ctx2 = canvas2.getContext("2d");

					// get the boundingbox of the rotated blue box

					var rectBB = getRotatedRectBB(result.boxes[0][1][0], result.boxes[0][1][1], fullBarcodeW, fullBarcodeH, result.angle);

					// clip the boundingbox of the rotated blue rect
					// to a temporary canvas

					canvas1.width = canvas2.width = rectBB.width;
					canvas1.height = canvas2.height = rectBB.height;

					ctx1.drawImage(img,
						rectBB.cx - rectBB.width / 2,
						rectBB.cy - rectBB.height / 2,
						rectBB.width,
						rectBB.height,
						0, 0, rectBB.width, rectBB.height
					);

					// unrotate the blue rect on the temporary canvas

					ctx2.translate(canvas1.width / 2, canvas1.height / 2);
					ctx2.rotate(-result.angle);
					ctx2.drawImage(canvas1, -canvas1.width / 2, -canvas1.height / 2);

					// draw the blue rect to the display canvas

					var offX = 0//rectBB.width / 2 - fullBarcodeW / 2; почему-то это мешает корректной работе в канвасе
					var offY = rectBB.height / 2 - fullBarcodeH / 2;

					canvas.width = fullBarcodeW;
					canvas.height = fullBarcodeH;
					console.log('TESTw TESTh: ', fullBarcodeW, fullBarcodeH)
					context.drawImage(canvas2, -offX, -offY);

				} // end start



				// Utility: get bounding box of rotated rectangle

				function getRotatedRectBB(x, y, width, height, rAngle) {
					var absCos = Math.abs(Math.cos(rAngle));
					var absSin = Math.abs(Math.sin(rAngle));
					var cx = x + width / 2 * Math.cos(rAngle) - height / 2 * Math.sin(rAngle);
					var cy = y + width / 2 * Math.sin(rAngle) + height / 2 * Math.cos(rAngle);
					var w = width //* absCos + height * absSin;   мешает корректной работе
					var h = width * absSin + height * absCos;
					return ({ cx: cx, cy: cy, width: w, height: h });
				}

			} else {
				console.log("not detected", result);
			}
		});

	}
	reader.readAsDataURL(file);
}
</script>

</html>