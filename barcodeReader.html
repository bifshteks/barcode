<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>RESULT</title>
</head>

<body>
    <div>
        <!-- <div class="inputoutput">
      <img id="imageSrc" alt="No Image" / >
      <div class="caption">imageSrc
        <input type="file" id="fileInput" name="file" />
      </div>
    </div> -->
        <p style="display: none;">
            Min value of detected pixel of start\end of barcode:
            <input id="valPix" type="range" min="0" max="255"> <span id="i1"></span>
            <br>
            <br> First param of weight vector:
            <input class="changeParam" id="firstWV" type="range" min="-10" max="10"> <span id="i2"></span>
            <br> Second param of weight vector:
            <input class="changeParam" id="secondWV" type="range" min="-10" max="10"> <span id="i3"></span>
            <br> Third param of weight vector:
            <input class="changeParam" id="thirdWV" type="range" min="-10" max="10"> <span id="i4"></span>
            <br>
            <br> Opaque:
            <input class="changeParam" id="opaque" type="range" min="-10" max="10"> <span id="i5"></span>
            <br>
        </p>
        <div class="inputoutput">
            Загрузите изображение для определения отношения ширины баркода в сантиметрах к ширине в пикселях:
            <input type="file" onchange="encodeImageFileAsURL(this)">
        </div>
        <canvas id="canvasCroped"></canvas>
        <div id="cannyTest"></div>
    </div>
    <canvas id="mid"></canvas>
</body>
<script src="jquery.min.js"></script>
<script src="quagga.js"></script>
<script src="tracking.js"></script>
<script>
function encodeImageFileAsURL(element) {
    // /////////////////////
    //  получаю полное изображениеб перевожу в BASE64
    ////////////////////////
    var file = element.files[0];
    var reader = new FileReader();
    reader.onloadend = function() {
        // /////////////////////
        //  запускаю квагу на полное изображение в base64
        ////////////////////////
        Quagga.decodeSingle({
            decoder: {
                readers: ["code_128_reader"]
            },
            locate: true,
            src: reader.result,
        }, function(result) {
            if (result.codeResult) {
                // /////////////////////
                //  получаю бокс с баркодом на полном изображении
                ////////////////////////
                var testFDW = result.boxes[0][0];
                var testSDW = result.boxes[0][3];
                var testFDH = result.boxes[0][0];
                var testSDH = result.boxes[0][1];
                var testW = Math.floor(Math.sqrt(Math.pow(testSDW[0] - testFDW[0], 2) + Math.pow(testSDW[1] - testFDW[1], 2)))
                var testH = Math.floor(Math.sqrt(Math.pow(testSDH[1] - testFDH[1], 2) + Math.pow(testSDH[0] - testFDH[0], 2)))

                var barcodeValue = parseFloat(result.codeResult.code.replace(',', '.'));
                var fullBarcodeW = testW;
                var fullBarcodeH = testH;

                // console.log('BOXES: ', result.boxes);
                // console.log('ANGLE: ', result.angle)

                var canvas = document.getElementById('canvasCroped');
                var context = canvas.getContext('2d');

                var img = new Image();
                img.src = reader.result;
                imgW = img.width;
                imgH = img.height;

                // /////////////////////
                //  обрезаю изображение и вставляю в холст обрезанное и перевернутое изображение
                ////////////////////////
                createCanvasWithCroppedBarcode();

                var croppedBarcodeData = canvas.toDataURL();

                // /////////////////////
                //  запускаю квагу на обрезанное изображение
                ////////////////////////
                Quagga.decodeSingle({
                    decoder: {
                        readers: ["code_128_reader"]
                    },
                    locate: true,
                    src: croppedBarcodeData 
                }, function(result) {

                    // /////////////////////
                    //  если квага хотя бы понимает, что баркод на изображении есть - получаю еще один бокс
                    //
                    // вставляю в холст обрезаный баркод с фильтром на вертикальные полосы
                    /////////////////////////////////////
                    var imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                    function setParam(firstWV, secondWV, thirdWV, opaque, valPix) {

                        function copyImageData(ctx, src) {
                            var dst = ctx.createImageData(src.width, src.height);
                            dst.data.set(src.data);
                            return dst;
                        }
                        var copyImageData = copyImageData(context, imageData);

                        var testImageData = copyImageData;
                        $('#i1').html(valPix)
                        $('#i2').html(firstWV)
                        $('#i3').html(secondWV)
                        $('#i4').html(thirdWV)
                        $('#i5').html(opaque)

                        var verticalImgPix = tracking.Image.verticalConvolve(copyImageData.data, canvas.width, canvas.height, [firstWV, secondWV, thirdWV], opaque)

                        for (i = 0; i < verticalImgPix.length; i++) {
                            testImageData.data[i] = verticalImgPix[i];
                        };
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        context.putImageData(testImageData, 0, 0);

                        changeParamFunc(valPix, verticalImgPix);
                        $('#valPix').on('change', function() {
                            changeParamFunc($(this).val(), verticalImgPix);
                            $('#i1').html($(this).val())
                        })
                    }
                    setParam(0, 1, 1, 1, 165);

                    $('.changeParam').on('change', function() {
                        setParam($('#firstWV').val(), $('#secondWV').val(), $('#thirdWV').val(), $('#opaque').val(), $('#valPix').val());
                    })


                    function changeParamFunc(maxPixVal, verticalImgPix) {
                        for (i = 0; i < verticalImgPix.length; i++) {
                            imageData.data[i] = verticalImgPix[i];
                        };
                        context.putImageData(imageData, 0, 0);


                        function getFullPixel(data, position) {
                            // функция достает из списка один полный n-й пиксель из 4 значений
                            var pix = {};
                            pix.r = data[position];
                            pix.g = data[position + 1];
                            pix.b = data[position + 2];
                            pix.a = data[position + 3];
                            return pix
                        }

                        /////////////////////////
                        // беру среднюю линию пикселей из обрезанного отфильтрованного изображения
                        /////////////////////////
                        var midH = Math.floor(canvas.height / 2);
                        var midW = midH + canvas.width * 4;
                        var middleLineData = imageData.data.slice(midH * midW, midH * midW + midW);
                        var pixelsInMiddleLineData = Math.floor(middleLineData.length / 4);

                        var startOfBarcode = 0;
                        var endOfBarcode = 0;

                        //////////////////////////
                        // прохожу по этой линии с начала до первой полоски бракода, потом с конца до последней полоски баркода
                        ///////////////////////
                        for (i = 0; i < pixelsInMiddleLineData; i++) {
                            // 'i' is one pixel rgba
                            var pixel = getFullPixel(middleLineData, i);

                            if (pixel.r < maxPixVal && pixel.g < maxPixVal && pixel.b < maxPixVal) { //if this pixel is start
                                startOfBarcode = i;

                                for (k = pixelsInMiddleLineData - 1; k > i; k--) {
                                    var pixelBackwards = getFullPixel(middleLineData, k);

                                    if (pixelBackwards.r < maxPixVal && pixelBackwards.g < maxPixVal && pixelBackwards.b < maxPixVal) {
                                        endOfBarcode = k;
                                        break;
                                    }
                                };
                                break;
                            }
                        };

                        var BARCODE_WIDTH = endOfBarcode - startOfBarcode;
                        console.log('barcodeValue: ', barcodeValue)
                        console.log('В одном сантиметре ', BARCODE_WIDTH / barcodeValue, ' пикселей')
                        $('#cannyTest').html('В одном сантиметре ' + BARCODE_WIDTH / barcodeValue + ' пикселей')
                    }
                });


                function createCanvasWithCroppedBarcode() {

                    // create 2 temporary canvases

                    var canvas1 = document.createElement("canvas");
                    var ctx1 = canvas1.getContext("2d");
                    var canvas2 = document.createElement("canvas");
                    var ctx2 = canvas2.getContext("2d");

                    // get the boundingbox of the rotated blue box

                    var rectBB = getRotatedRectBB(result.boxes[0][1][0], result.boxes[0][1][1], fullBarcodeW, fullBarcodeH, result.angle);

                    // clip the boundingbox of the rotated blue rect
                    // to a temporary canvas

                    canvas1.width = canvas2.width = rectBB.width;
                    canvas1.height = canvas2.height = rectBB.height;

                    ctx1.drawImage(img,
                        rectBB.cx - rectBB.width / 2,
                        rectBB.cy - rectBB.height / 2,
                        rectBB.width,
                        rectBB.height,
                        0, 0, rectBB.width, rectBB.height
                    );

                    // unrotate the blue rect on the temporary canvas

                    ctx2.translate(canvas1.width / 2, canvas1.height / 2);
                    ctx2.rotate(-result.angle);
                    ctx2.drawImage(canvas1, -canvas1.width / 2, -canvas1.height / 2);

                    // draw the blue rect to the display canvas

                    var offX = 0 //rectBB.width / 2 - fullBarcodeW / 2; почему-то это мешает корректной работе в канвасе
                    var offY = rectBB.height / 2 - fullBarcodeH / 2;

                    canvas.width = fullBarcodeW;
                    canvas.height = fullBarcodeH;
                    context.drawImage(canvas2, -offX, -offY);

                }



                // Utility: get bounding box of rotated rectangle

                function getRotatedRectBB(x, y, width, height, rAngle) {
                    var absCos = Math.abs(Math.cos(rAngle));
                    var absSin = Math.abs(Math.sin(rAngle));
                    var cx = x + width / 2 * Math.cos(rAngle) - height / 2 * Math.sin(rAngle);
                    var cy = y + width / 2 * Math.sin(rAngle) + height / 2 * Math.cos(rAngle);
                    var w = width //* absCos + height * absSin;   мешает корректной работе
                    var h = width * absSin + height * absCos;
                    return ({ cx: cx, cy: cy, width: w, height: h });
                }

            } else {
                console.log("not detected", result);
            }
        });
    }
    reader.readAsDataURL(file);
}
</script>

</html>